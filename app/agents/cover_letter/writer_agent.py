"""
Cover Letter Writer Agent

This agent takes the analysis outline and writes compelling cover letter content.
"""

try:
    import os
    # Try to use real Google ADK by default, fall back to mock for testing
    if os.getenv('USE_MOCK_ADK', 'false').lower() == 'true':
        raise ImportError("Mock ADK forced for testing")
    from google.adk.agents import LlmAgent
    from google.adk.tools import FunctionTool
    from google.genai import types
    print("✅ Using real Google ADK")
except ImportError:
    print("⚠️ Google ADK not available, using mock implementation")
    # Import mock implementation
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(__file__)))))
    from mock_adk import LlmAgent, FunctionTool
    # Mock types module
    import types

    class MockGenerateContentConfig:
        def __init__(self, temperature=0.1, response_mime_type=None, response_schema=None):
            self.temperature = temperature
            self.response_mime_type = response_mime_type
            self.response_schema = response_schema

    types.GenerateContentConfig = MockGenerateContentConfig
    types.Content = type('Content', (), {
        '__init__': lambda self, role, parts: None
    })
    types.Part = type('Part', (), {
        '__init__': lambda self, text=None, inline_data=None: None
    })

from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
import json


class CoverLetterContent(BaseModel):
    """Schema for cover letter content generated by writer agent"""
    opening_paragraph: str = Field(description="Compelling opening paragraph with hook and fit statement")
    body_paragraphs: List[str] = Field(description="2-3 body paragraphs with evidence and achievements")
    company_connection: Optional[str] = Field(description="Optional paragraph about company connection/mission alignment")
    closing_paragraph: str = Field(description="Strong closing with call-to-action")
    tone: str = Field(description="Recommended tone (professional, creative, enthusiastic, formal)")


def create_cover_letter_writer_agent(resume_query_tool, job_description_query_tool):
    """
    Create the cover letter writer agent that drafts compelling content.

    Args:
        resume_query_tool: Function to query resume data from ChromaDB
        job_description_query_tool: Function to query job description data from ChromaDB

    Returns:
        LlmAgent configured for cover letter writing
    """
    schema_string = CoverLetterContent.model_json_schema()

    writer_agent = LlmAgent(
    model="gemini-2.5-pro",
    name="cover_letter_writer_agent",
    description="Write compelling, personalized cover letter content based on analysis outline",
    instruction=(
        "## Persona ##"
        "\nYou are an expert career storyteller and professional cover letter writer. You excel at weaving a candidate's experience into a compelling narrative that directly addresses an employer's needs."

        "\n\n## Goal ##"
        "\nYour goal is to synthesize information from a candidate's resume and a job description to write an engaging, personalized cover letter. The final output must be a structured JSON object."

        "\n\n## Tools ##"
        "\nYou have access to the following tools to conduct your research:"
        "\n1. `resume_query_tool(queries: list[str])`: Use this tool to find the **raw materials** for your narrative. Query it to find specific experiences, projects, and skills from the candidate's resume that can be used as evidence."
        "\n2. `job_description_query_tool(queries: list[str])`: Use this tool to understand the **goal** of your narrative. Query it to identify the key requirements, responsibilities, and desired qualifications for the role."

        "\n\n## Process ##"
        "\n1. **Analyze the Target:** First, use the `job_description_query_tool` to understand what the employer is looking for. Identify the top 3-4 most critical requirements of the job."
        "\n2. **Find the Evidence:** Next, use the `resume_query_tool` to search for specific examples, quantifiable achievements, and project outcomes from the candidate's background that directly address the requirements you identified."
        "\n3. **Construct the Narrative:** Weave the evidence you found into a compelling story that includes:"
        "\n    - A compelling opening paragraph that hooks the reader and states your fitness for the role."
        "\n    - 2-3 body paragraphs that provide specific proof of your skills and achievements, connecting them directly to the job's needs."
        "\n    - A paragraph that shows a genuine connection to the company's mission, values, or recent projects."
        "\n    - A strong closing paragraph with a clear call-to-action."
        "\n4. **Refine and Polish:** Review your draft against the Writing Guidelines to ensure the highest quality."

        "\n\n## Writing Guidelines ##"
        "\n- **Length:** Keep the total word count between 250-450 words."
        "\n- **Specificity:** Use active voice and strong action verbs. Prioritize quantifiable achievements."
        "\n- **Tone:** Maintain a professional yet personable and enthusiastic tone."
        "\n- **Authenticity:** Avoid generic clichés. Be specific to the candidate and the role."
        
        "\n\n## Output Instructions ##"
        "\nCRITICAL: Your final response MUST be a single, valid JSON object. Do not include markdown fences or any other text."
        f"JSON SCHEMA: \n{schema_string}"
    ),
    generate_content_config=types.GenerateContentConfig(
        temperature=0.3,  # Higher temperature for creative writing
    ),
    output_schema=CoverLetterContent,
    output_key="content",
    tools=[resume_query_tool, job_description_query_tool],
    )

    return writer_agent


async def run_cover_letter_writing(
    writer_agent,
    analysis_outline: str,
    resume_id: str,
    job_description_url: str,
    optional_prompt: Optional[str],
    session_service,
    session_id: str,
    user_id: str = "user_123"
):
    """
    Run the cover letter writing using the writer agent.

    Args:
        writer_agent: The configured writer agent
        analysis_outline: The outline from the analyst agent
        resume_id: ID of the resume
        job_description_url: URL of the job description
        optional_prompt: Optional user prompt for tone or focus
        session_service: ADK session service
        session_id: Session ID for the agent run
        user_id: User ID for the session

    Returns:
        Dict containing the written content
    """

    from google.adk.runners import Runner

    # Create the session first
    session = await session_service.create_session(
        app_name="cover_letter_writing",
        user_id=user_id,
        session_id=session_id
    )

    runner = Runner(agent=writer_agent, session_service=session_service, app_name="cover_letter_writing")

    # Build the prompt with analysis context
    prompt_parts = [
        f"Write a compelling cover letter for resume {resume_id} and job at {job_description_url}.",
        f"Analysis outline: {analysis_outline}"
    ]

    if optional_prompt:
        prompt_parts.append(f"Additional instructions: {optional_prompt}")

    content_parts = [
        types.Part(text="\n\n".join(prompt_parts))
    ]

    content = types.Content(
        role='user',
        parts=content_parts
    )

    writing_result = None
    def _try_parse_json(s: str):
        try:
            return json.loads(s)
        except json.JSONDecodeError:
            pass
        s2 = s.strip()
        if s2.startswith("```"):
            s2 = s2.strip('`')
            if s2.lower().startswith("json\n"):
                s2 = s2[5:]
        start = s2.find('{')
        end = s2.rfind('}')
        if start != -1 and end != -1 and end > start:
            cand = s2[start:end+1]
            try:
                return json.loads(cand)
            except json.JSONDecodeError:
                pass
        return None

    async for event in runner.run_async(new_message=content, session_id=session_id, user_id=user_id):
        if event.is_final_response() and event.content:
            if hasattr(event.content, 'parts') and event.content.parts:
                raw_text = event.content.parts[0].text.strip()
                parsed = _try_parse_json(raw_text)
                if parsed is not None:
                    writing_result = parsed
                    print("✅ Cover letter writing completed successfully")
                else:
                    print("❌ Failed to parse writing result: Invalid JSON after cleanup")
                    print(f"Raw response: {raw_text}")

    return writing_result
